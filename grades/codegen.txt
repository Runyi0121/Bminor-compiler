=====STUDENT TESTS=====
====Good Tests====
===[STUDENT TESTS/good1.bminor Input]===
x: integer = 1;
y: integer = 100000;
main: function void ()=
{
	x: integer = y * 10 + 15 - 4;
}
	
===[STUDENT TESTS/good1.bminor Status]===
return code: 0
===[good1.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good1.bminor"
# DECL
.data
.global x
x:
.quad 1
# DECL
.data
.global y
y:
.quad 100000
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# DECL
# code for value of decl x
# EXPR
# code of sub
# EXPR
# code of add
# EXPR
# code of mult
# EXPR
# EXPR
	movq $10, %rbx
	movq %rbx, %rax
	imulq %rbx
	movq %rax, %rbx
# EXPR
	movq $15, %rbx
	addq %rbx, %rbx
# EXPR
	movq $4, %rbx
	subq %rbx, %rbx
# code for decl x
	movq %rbx, -8(%rbp)
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good1.bminor Output]===
x:integer = 1;
y:integer = 100000;
main:function void () = {
	x:integer = (y * 10 + 15) - 4;
}
y resolves to global y




===[STUDENT TESTS/good10.bminor Input]===
x: array [5] integer = {1,2,3,4,5};
y: array [5] array [5] integer;

main: function void () =
{
	y[1] = x;
	count: integer;
	for(count = 0; count < 5; count++)
	{
		y[count] = x;
	} 	
}
===[STUDENT TESTS/good10.bminor Status]===
return code: 0
===[good10.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good10.bminor"
# DECL
.data
.global x
x:
.quad 1
.quad 2
.quad 3
.quad 4
.quad 5
# DECL
.data
.global y
y:
.quad 0
.quad 0
.quad 0
.quad 0
.quad 0
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# EXPR
# STMT
# DECL
# STMT
# start of for loop
# init expr
# EXPR
.L0:
# condition expr
# EXPR
# code of cmp 
# EXPR
# EXPR
	movq $5, %rbx
# CMP
	cmpq %rbx, %rbx
	jl .L2
# if false
.L3:
	movq $0, %rbx
	jmp .L4
# if true
.L2:
	movq $1, %rbx
	jmp .L4
# continue
.L4:
	cmpq $0, %rbx
	je .L1
# loop body
# STMT
# STMT
# EXPR
# next expr
# EXPR
# code of ++
# EXPR
	movq %rbx, %rbx
	incq %rbx
	movq %rbx, -8(%rbp)
	jmp .L0
.L1:
# end of for loop
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good10.bminor Output]===
x:array[5] integer = {1, 2, 3, 4, 5};
y:array[5] array[5] integer;
main:function void () = {
}
y resolves to global y
x resolves to global x
count resolves to local 1
count resolves to local 1
count resolves to local 1
y resolves to global y
count resolves to local 1
x resolves to global x




===[STUDENT TESTS/good11.bminor Input]===
main:function integer ()=
{
	return 10;
}
===[STUDENT TESTS/good11.bminor Status]===
return code: 0
===[good11.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good11.bminor"
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# return stmt
# EXPR
	movq $10, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good11.bminor Output]===
main:function integer () = {
	return 10;
}




===[STUDENT TESTS/good12.bminor Input]===
// tests addition
main:function integer ()=
{
	return 8 + 2;
}
===[STUDENT TESTS/good12.bminor Status]===
return code: 0
===[good12.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good12.bminor"
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# return stmt
# EXPR
# code of add
# EXPR
	movq $8, %rbx
# EXPR
	movq $2, %r10
	addq %rbx, %r10
	movq %r10, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good12.bminor Output]===
main:function integer () = {
	return 8 + 2;
}




===[STUDENT TESTS/good13.bminor Input]===
// tests multiplication
main:function integer ()=
{
	return 5 * 2;
}
===[STUDENT TESTS/good13.bminor Status]===
return code: 0
===[good13.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good13.bminor"
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# return stmt
# EXPR
# code of mult
# EXPR
	movq $5, %rbx
# EXPR
	movq $2, %r10
	movq %r10, %rax
	imulq %rbx
	movq %rax, %r10
	movq %r10, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good13.bminor Output]===
main:function integer () = {
	return 5 * 2;
}




===[STUDENT TESTS/good14.bminor Input]===
// tests division
main:function integer ()=
{
	return 20 / 2;
}
===[STUDENT TESTS/good14.bminor Status]===
return code: 0
===[good14.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good14.bminor"
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# return stmt
# EXPR
# code of div
# EXPR
	movq $20, %rbx
# EXPR
	movq $2, %r10
	movq %rbx, %rax
	xor %rdx, %rdx
	idivq %r10
	movq %rax, %r10
	movq %r10, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good14.bminor Output]===
main:function integer () = {
	return 20 / 2;
}




===[STUDENT TESTS/good15.bminor Input]===
// Adds a global variable
x:integer=5;
main:function integer ()=
{
	return x + x;
}
===[STUDENT TESTS/good15.bminor Status]===
return code: 0
===[good15.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good15.bminor"
# DECL
.data
.global x
x:
.quad 5
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# return stmt
# EXPR
# code of add
# EXPR
# EXPR
	addq %rbx, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good15.bminor Output]===
x:integer = 5;
main:function integer () = {
	return x + x;
}
x resolves to global x
x resolves to global x




===[STUDENT TESTS/good16.bminor Input]===
// Adds a local variable
x:integer=5;
main:function integer ()=
{
y:integer = 2;
	return x * y;
}
===[STUDENT TESTS/good16.bminor Status]===
return code: 0
===[good16.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good16.bminor"
# DECL
.data
.global x
x:
.quad 5
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# DECL
# code for value of decl y
# EXPR
	movq $2, %rbx
# code for decl y
	movq %rbx, -8(%rbp)
# STMT
# return stmt
# EXPR
# code of mult
# EXPR
# EXPR
	movq %rbx, %rax
	imulq %rbx
	movq %rax, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good16.bminor Output]===
x:integer = 5;
main:function integer () = {
	y:integer = 2;
	return x * y;
}
x resolves to global x
y resolves to local 1




===[STUDENT TESTS/good17.bminor Input]===
// Uses a complex expression
x:integer=5;
main:function integer () =
{
	y:integer = 2;
	return (x + 10) * y - x*4;
}
===[STUDENT TESTS/good17.bminor Status]===
return code: 0
===[good17.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good17.bminor"
# DECL
.data
.global x
x:
.quad 5
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# DECL
# code for value of decl y
# EXPR
	movq $2, %rbx
# code for decl y
	movq %rbx, -8(%rbp)
# STMT
# return stmt
# EXPR
# code of sub
# EXPR
# code of mult
# EXPR
# code of add
# EXPR
# EXPR
	movq $10, %rbx
	addq %rbx, %rbx
# EXPR
	movq %rbx, %rax
	imulq %rbx
	movq %rax, %rbx
# EXPR
# code of mult
# EXPR
# EXPR
	movq $4, %rbx
	movq %rbx, %rax
	imulq %rbx
	movq %rax, %rbx
	subq %rbx, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good17.bminor Output]===
x:integer = 5;
main:function integer () = {
	y:integer = 2;
	return (x + 10) * y - x * 4;
}
x resolves to global x
y resolves to local 1
x resolves to global x




===[STUDENT TESTS/good18.bminor Input]===
// tests character printing
i:char= 'i';
main:function integer () =
{
	n:char ='n';
	print 'h', i,' ', n, 'd'; 
}
===[STUDENT TESTS/good18.bminor Status]===
return code: 0
===[good18.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good18.bminor"
# DECL
.data
.global i
i:
.quad 105
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# DECL
# code for value of decl n
# EXPR
	movq $110, %rbx
# code for decl n
	movq %rbx, -8(%rbp)
# STMT
# printing exprs
	pushq %r10
	pushq %r11
# EXPR
	movq $104, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
	movq $32, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
	movq $100, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good18.bminor Output]===
i:char = 'i';
main:function integer () = {
	n:char = 'n';
	print 'h', i, ' ', n, 'd';
}
i resolves to global i
n resolves to local 1




===[STUDENT TESTS/good19.bminor Input]===
x:integer=5;
main:function integer ()=
{
y:integer = 2;
	return x * y;
}

===[STUDENT TESTS/good19.bminor Status]===
return code: 0
===[good19.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good19.bminor"
# DECL
.data
.global x
x:
.quad 5
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# DECL
# code for value of decl y
# EXPR
	movq $2, %rbx
# code for decl y
	movq %rbx, -8(%rbp)
# STMT
# return stmt
# EXPR
# code of mult
# EXPR
# EXPR
	movq %rbx, %rax
	imulq %rbx
	movq %rax, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good19.bminor Output]===
x:integer = 5;
main:function integer () = {
	y:integer = 2;
	return x * y;
}
x resolves to global x
y resolves to local 1




===[STUDENT TESTS/good2.bminor Input]===
main: function integer (x: integer) = {
    if (x < 0) {
        return -x;
    } else {
        return x;
    }
}
===[STUDENT TESTS/good2.bminor Status]===
return code: 0
===[good2.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good2.bminor"
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# start of if stmt
# condition expr
# EXPR
# code of cmp 
# EXPR
# EXPR
	movq $0, %rbx
# CMP
	cmpq %rbx, %rbx
	jl .L2
# if false
.L3:
	movq $0, %rbx
	jmp .L4
# if true
.L2:
	movq $1, %rbx
	jmp .L4
# continue
.L4:
	cmpq $0, %rbx
	je .L0
# if body
# STMT
# STMT
# return stmt
# EXPR
# code of negate
# EXPR
	negq %rbx
	movq %rbx, %rax
	jmp .main_epilogue
	jmp .L1
# false label
.L0:
# else body
# STMT
# STMT
# return stmt
# EXPR
	movq %rbx, %rax
	jmp .main_epilogue
.L1:
# end of if stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good2.bminor Output]===
main:function integer ( x: integer ) = {
	if (x < 0) {
		return (x);
	}
	else {
		return x;
	}
}
x resolves to param 1
x resolves to param 1
x resolves to param 1




===[STUDENT TESTS/good20.bminor Input]===
// tests if statements 
x:integer = 5;
main:function integer () =
{
	if(false)
		x=15;
	else
		x=10;


	if(true)
	{
		return x;
	}
	else
	{
		return 1;
	}	
	
}
===[STUDENT TESTS/good20.bminor Status]===
return code: 0
===[good20.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good20.bminor"
# DECL
.data
.global x
x:
.quad 5
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# start of if stmt
# condition expr
# EXPR
	movq $1, %rbx
	cmpq $0, %rbx
	je .L0
# if body
# STMT
# EXPR
	jmp .L1
# false label
.L0:
# else body
# STMT
# EXPR
.L1:
# end of if stmt
# STMT
# start of if stmt
# condition expr
# EXPR
	movq $0, %rbx
	cmpq $0, %rbx
	je .L2
# if body
# STMT
# STMT
# return stmt
# EXPR
	movq %rbx, %rax
	jmp .main_epilogue
	jmp .L3
# false label
.L2:
# else body
# STMT
# STMT
# return stmt
# EXPR
	movq $1, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
.L3:
# end of if stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good20.bminor Output]===
x:integer = 5;
main:function integer () = {
	if (false) {
	}
	else {
	}
	if (true) {
		return x;
	}
	else {
		return 1;
	}
}
x resolves to global x
x resolves to global x
x resolves to global x




===[STUDENT TESTS/good3.bminor Input]===
/* Test name resolution at multiple scope levels. */

x: integer = 5;
y: integer = 10;

main: function void () =
{
	x: integer = 5;
	y: integer = 10;

	y = x + y;

}
===[STUDENT TESTS/good3.bminor Status]===
return code: 0
===[good3.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good3.bminor"
# DECL
.data
.global x
x:
.quad 5
# DECL
.data
.global y
y:
.quad 10
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $16, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# DECL
# code for value of decl x
# EXPR
	movq $5, %rbx
# code for decl x
	movq %rbx, -8(%rbp)
# STMT
# DECL
# code for value of decl y
# EXPR
	movq $10, %rbx
# code for decl y
	movq %rbx, -16(%rbp)
# STMT
# EXPR
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good3.bminor Output]===
x:integer = 5;
y:integer = 10;
main:function void () = {
	x:integer = 5;
	y:integer = 10;
}
y resolves to local 2
x resolves to local 1
y resolves to local 2




===[STUDENT TESTS/good4.bminor Input]===
x: integer;
y: boolean;
main: function integer (a: boolean, z: integer) = {
    z = x + 3 - 4 * z / x;
    z++;
    -z--;
    x = 3^z^x;
    x = z % x + 2;
    return x + z^2;
}
===[STUDENT TESTS/good4.bminor Status]===
return code: 0
===[good4.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good4.bminor"
# DECL
.data
.global x
x:
.quad 0
# DECL
.data
.global y
y:
	.quad 0
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	pushq %rsi
	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# EXPR
# STMT
# EXPR
# code of ++
# EXPR
	movq %rbx, %rbx
	incq %rbx
	movq %rbx, -16(%rbp)
# STMT
# EXPR
# code of negate
# EXPR
# code of --
# EXPR
	movq %rbx, %rbx
	decq %rbx
	movq %rbx, -16(%rbp)
	negq %rbx
# STMT
# EXPR
# STMT
# EXPR
# STMT
# return stmt
# EXPR
# code of add
# EXPR
# EXPR
# code of exp
# EXPR
# EXPR
	movq $2, %rbx
	pushq %r10
	pushq %r11
	movq %rbx, %rdi
	movq %rbx, %rsi
	call integer_power
	popq %r11
	popq %r10
	movq %rax, %rbx
	addq %rbx, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good4.bminor Output]===
x:integer;
y:boolean;
main:function integer ( a: boolean, z: integer ) = {
}
z resolves to param 2
x resolves to global x
z resolves to param 2
x resolves to global x
z resolves to param 2
z resolves to param 2
x resolves to global x
z resolves to param 2
x resolves to global x
x resolves to global x
z resolves to param 2
x resolves to global x
x resolves to global x
z resolves to param 2




===[STUDENT TESTS/good5.bminor Input]===
x: array [5] integer = {1,2,3,4,5};
y: array [5] array [5] integer;

main: function void () =
{
	y[1] = x;
	count: integer;
	for(count = 0; count < 5; count++)
	{
		y[count] = x;
	} 	
}
===[STUDENT TESTS/good5.bminor Status]===
return code: 0
===[good5.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good5.bminor"
# DECL
.data
.global x
x:
.quad 1
.quad 2
.quad 3
.quad 4
.quad 5
# DECL
.data
.global y
y:
.quad 0
.quad 0
.quad 0
.quad 0
.quad 0
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# EXPR
# STMT
# DECL
# STMT
# start of for loop
# init expr
# EXPR
.L0:
# condition expr
# EXPR
# code of cmp 
# EXPR
# EXPR
	movq $5, %rbx
# CMP
	cmpq %rbx, %rbx
	jl .L2
# if false
.L3:
	movq $0, %rbx
	jmp .L4
# if true
.L2:
	movq $1, %rbx
	jmp .L4
# continue
.L4:
	cmpq $0, %rbx
	je .L1
# loop body
# STMT
# STMT
# EXPR
# next expr
# EXPR
# code of ++
# EXPR
	movq %rbx, %rbx
	incq %rbx
	movq %rbx, -8(%rbp)
	jmp .L0
.L1:
# end of for loop
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good5.bminor Output]===
x:array[5] integer = {1, 2, 3, 4, 5};
y:array[5] array[5] integer;
main:function void () = {
}
y resolves to global y
x resolves to global x
count resolves to local 1
count resolves to local 1
count resolves to local 1
y resolves to global y
count resolves to local 1
x resolves to global x




===[STUDENT TESTS/good6.bminor Input]===
main: function void ( x: integer, y:integer, z:integer ) = {
    r: integer;
	b: boolean;
          
	r = (x+y)/z;
	r = x+(y+z);
	b = (true||false) && (false||true);

	r = x+(y/z);
	r = (x+y)+z;
	b = (x+y) < (x+z);
	b = (true&&false) || (false&&true);
}
===[STUDENT TESTS/good6.bminor Status]===
return code: 0
===[good6.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good6.bminor"
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	pushq %rdi
	pushq %rsi
	pushq %rdx
	subq $16, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# DECL
# STMT
# DECL
# STMT
# EXPR
# STMT
# EXPR
# STMT
# EXPR
# STMT
# EXPR
# STMT
# EXPR
# STMT
# EXPR
# STMT
# EXPR
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good6.bminor Output]===
main:function void ( x: integer, y: integer, z: integer ) = {
	r:integer;
	b:boolean;
}
r resolves to local 4
x resolves to param 1
y resolves to param 2
z resolves to param 3
r resolves to local 4
x resolves to param 1
y resolves to param 2
z resolves to param 3
b resolves to local 5
r resolves to local 4
x resolves to param 1
y resolves to param 2
z resolves to param 3
r resolves to local 4
x resolves to param 1
y resolves to param 2
z resolves to param 3
b resolves to local 5
x resolves to param 1
y resolves to param 2
x resolves to param 1
z resolves to param 3
b resolves to local 5




===[STUDENT TESTS/good7.bminor Input]===
strings: string = "bye";
main: function string () = {
    if (false) {
        return "hello";
    }
    else {
        return strings;
    }
}


===[STUDENT TESTS/good7.bminor Status]===
return code: 0
===[good7.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good7.bminor"
# DECL
.data
.global strings
strings:
.quad .L0
.data
.global .L0
.L0:
.string "bye"
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# start of if stmt
# condition expr
# EXPR
	movq $1, %rbx
	cmpq $0, %rbx
	je .L1
# if body
# STMT
# STMT
# return stmt
# EXPR
.data
.L3:
	.string "hello"
.text
	leaq .L3, %r10
	movq %r10, %rax
	jmp .main_epilogue
	jmp .L2
# false label
.L1:
# else body
# STMT
# STMT
# return stmt
# EXPR
	movq %rbx, %rax
	jmp .main_epilogue
.L2:
# end of if stmt
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good7.bminor Output]===
strings:string = "bye";
main:function string () = {
	if (false) {
		return "hello";
	}
	else {
		return strings;
	}
}
strings resolves to global strings




===[STUDENT TESTS/good8.bminor Input]===
/* Update one element of an array. */

August:array [5] integer = {1,2,3,4,5};

main:function void () =
{
	August[4] = 4;
}
===[STUDENT TESTS/good8.bminor Status]===
return code: 0
===[good8.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good8.bminor"
# DECL
.data
.global August
August:
.quad 1
.quad 2
.quad 3
.quad 4
.quad 5
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# EXPR
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good8.bminor Output]===
August:array[5] integer = {1, 2, 3, 4, 5};
main:function void () = {
}
August resolves to global August




===[STUDENT TESTS/good9.bminor Input]===
a: integer = 1;
b: integer = 2;
c: boolean = false;
d: string = "hello";
str: string = "ohno";
main: function boolean () = {
    return (a > b) && (a < b) || (a <= b);
    return true;
    return (a >= b) && (a != b) || (a == b);
    return (d == str) || (d != str);
}

===[STUDENT TESTS/good9.bminor Status]===
return code: 0
===[good9.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/codegen-grading/rshi2-compiler/test/codegen/good9.bminor"
# DECL
.data
.global a
a:
.quad 1
# DECL
.data
.global b
b:
.quad 2
# DECL
.data
.global c
c:
	.quad 1
# DECL
.data
.global d
d:
.quad .L0
.data
.global .L0
.L0:
.string "hello"
# DECL
.data
.global str
str:
.quad .L1
.data
.global .L1
.L1:
.string "ohno"
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# return stmt
# EXPR
# code for or
# EXPR
# code for and
# EXPR
# code of cmp 
# EXPR
# EXPR
# CMP
	cmpq %rbx, %rbx
	jg .L2
# if false
.L3:
	movq $0, %rbx
	jmp .L4
# if true
.L2:
	movq $1, %rbx
	jmp .L4
# continue
.L4:
# EXPR
# code of cmp 
# EXPR
# EXPR
# CMP
	cmpq %rbx, %rbx
	jl .L5
# if false
.L6:
	movq $0, %rbx
	jmp .L7
# if true
.L5:
	movq $1, %rbx
	jmp .L7
# continue
.L7:
	andq %rbx, %rbx
# EXPR
# code of cmp 
# EXPR
# EXPR
# CMP
	cmpq %rbx, %rbx
	jle .L8
# if false
.L9:
	movq $0, %rbx
	jmp .L10
# if true
.L8:
	movq $1, %rbx
	jmp .L10
# continue
.L10:
	orq %rbx, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# STMT
# return stmt
# EXPR
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# STMT
# return stmt
# EXPR
# code for or
# EXPR
# code for and
# EXPR
# code of cmp 
# EXPR
# EXPR
# CMP
	cmpq %rbx, %rbx
	jge .L11
# if false
.L12:
	movq $0, %rbx
	jmp .L13
# if true
.L11:
	movq $1, %rbx
	jmp .L13
# continue
.L13:
# EXPR
# code of cmp 
# EXPR
# EXPR
# CMP
	cmpq %rbx, %rbx
	jne .L14
# if false
.L15:
	movq $0, %rbx
	jmp .L16
# if true
.L14:
	movq $1, %rbx
	jmp .L16
# continue
.L16:
	andq %rbx, %rbx
# EXPR
# code of cmp 
# EXPR
# EXPR
# CMP
	cmpq %rbx, %rbx
	je .L17
# if false
.L18:
	movq $0, %rbx
	jmp .L19
# if true
.L17:
	movq $1, %rbx
	jmp .L19
# continue
.L19:
	orq %rbx, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# STMT
# return stmt
# EXPR
# code for or
# EXPR
# code of cmp 
# EXPR
# EXPR
# CMP
	pushq %r10
	pushq %r11
	movq %rbx, %rdi
	movq %rbx, %rsi
	call string_compare
	popq %r11
	popq %r10
	cmpq $1, %rax
	je .L20
# if false
.L21:
	movq $0, %rbx
	jmp .L22
# if true
.L20:
	movq $1, %rbx
	jmp .L22
# continue
.L22:
# EXPR
# code of cmp 
# EXPR
# EXPR
# CMP
	pushq %r10
	pushq %r11
	movq %rbx, %rdi
	movq %rbx, %rsi
	call string_compare
	popq %r11
	popq %r10
	cmpq $1, %rax
	jne .L23
# if false
.L24:
	movq $0, %rbx
	jmp .L25
# if true
.L23:
	movq $1, %rbx
	jmp .L25
# continue
.L25:
	orq %rbx, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

Test passed successfully!

===[STUDENT TESTS/good9.bminor Output]===
a:integer = 1;
b:integer = 2;
c:boolean = false;
d:string = "hello";
str:string = "ohno";
main:function boolean () = {
	return a > b && a < b || a <= b;
	return true;
	return a >= b && a != b || a == b;
	return d == str || d != str;
}
a resolves to global a
b resolves to global b
a resolves to global a
b resolves to global b
a resolves to global a
b resolves to global b
a resolves to global a
b resolves to global b
a resolves to global a
b resolves to global b
a resolves to global a
b resolves to global b
d resolves to global d
str resolves to global str
d resolves to global d
str resolves to global str




=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
strlen: function integer(s: string);
f: function integer(i: integer);

main: function integer () = {
	if (f(strlen("hi")) > strlen("there")) {print "no\n";}
	if (f(f(strlen("hi"))) > strlen("there")) print "ok\n";

	return 0;
}

f: function integer(i: integer) = {
	return i*2;
}

===Compiler returned nonzero return code===


===[good1.bminor Assembly Output]===
.data
.L0: .string "no\n"
.L1: .string "hi"
.L2: .string "there"
.L3: .string "ok\n"
.L4: .string "hi"
.L5: .string "there"

.text
.global strlen
strlen:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body


.strlen_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global f
f:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body


.f_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global main
main:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body

# Function call 
movq $.L2, %rbx
movq %rbx, %rdi
pushq %r10
pushq %r11
call strlen
popq %r11
popq %r10

movq %rax, %rbx

# Function call 

# Function call 
movq $.L1, %r10
movq %r10, %rdi
pushq %r10
pushq %r11
call strlen
popq %r11
popq %r10

movq %rax, %r10
movq %r10, %rdi
pushq %r10
pushq %r11
call f
popq %r11
popq %r10

movq %rax, %r10
cmp %rbx, %r10
jg .L6
movq $0, %r10
jmp .L7
.L6:
movq $1, %r10
.L7:
cmp $0, %r10
je .L8
movq $.L0, %rbx

# Print call: 
movq %rbx, %rdi
pushq %r10
pushq %r11
call print_string
popq %r11
popq %r10

jmp .L9
.L8:
.L9:

# Function call 
movq $.L5, %rbx
movq %rbx, %rdi
pushq %r10
pushq %r11
call strlen
popq %r11
popq %r10

movq %rax, %rbx

# Function call 

# Function call 

# Function call 
movq $.L4, %r10
movq %r10, %rdi
pushq %r10
pushq %r11
call strlen
popq %r11
popq %r10

movq %rax, %r10
movq %r10, %rdi
pushq %r10
pushq %r11
call f
popq %r11
popq %r10

movq %rax, %r10
movq %r10, %rdi
pushq %r10
pushq %r11
call f
popq %r11
popq %r10

movq %rax, %r10
cmp %rbx, %r10
jg .L10
movq $0, %r10
jmp .L11
.L10:
movq $1, %r10
.L11:
cmp $0, %r10
je .L12
movq $.L3, %rbx

# Print call: 
movq %rbx, %rdi
pushq %r10
pushq %r11
call print_string
popq %r11
popq %r10

jmp .L13
.L12:
.L13:
movq $0, %rbx
movq %rbx, %rax
jmp .main_epilogue


.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global f
f:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body
movq $2, %rbx

# Name
movq -8(%rbp), %r10
movq %r10, %rax
imulq %rbx
movq %rax, %r10
movq %r10, %rax
jmp .f_epilogue


.f_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

TEST NOT PASSED - COMPILE ERROR

===[good1.bminor Output]===

/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good1.bminor.s: Assembler messages:
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good1.bminor.s:212: Error: symbol `f' is already defined
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good1.bminor.s:238: Error: symbol `.f_epilogue' is already defined

return code: 1


===[good10.bminor Input]===
w: string = "no";

f: function void (s: string) = {
	{
		w: string = "ok";
		print w, "\n";
		w = "bad!\n";
	}
	print s, ' ', w;
	print " ";
	s = "changed\n";
	print s;
}

main:function integer ()= {
	s: string = "good";
	f(s);
	print s;

	return 0;
}

===Compiler returned nonzero return code===


===[good10.bminor Assembly Output]===
.data
w:
	.string "no"
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global f
f:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %%rdi
	SUBQ $16, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.data
.L0:
	.string "ok"
.text
MOVQ $.L0, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	CALL print_string
.data
.L1:
	.string "\n"
.text
MOVQ $.L1, %rbx
	MOVQ %rbx, %rdi
	CALL print_string
.data
.L2:
	.string "bad!\n"
.text
MOVQ $.L2, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	CALL print_string
	MOVQ $32, %rbx
	MOVQ %rbx, %rdi
	CALL print_character
	LEAQ w, %rbx
	MOVQ %rbx, %rdi
	CALL print_string
.data
.L3:
	.string " "
.text
MOVQ $.L3, %rbx
	MOVQ %rbx, %rdi
	CALL print_string
.data
.L4:
	.string "changed\n"
.text
MOVQ $.L4, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	CALL print_string
.f_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $16, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.data
.L5:
	.string "good"
.text
MOVQ $.L5, %rbx
	MOVQ %rbx, -8(%rbp)
	PUSHQ %r10
	PUSHQ %r11
	MOVQ -8(%rbp), %rbx
MOVQ %rbx, %%rdi
CALL f
	POPQ %r11
	POPQ %r10
MOVQ %rax, %rbx
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	CALL print_string
	MOVQ $0, %rbx
	MOVQ %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	MOVQ $0, %rax
	RET

TEST NOT PASSED - COMPILE ERROR

===[good10.bminor Output]===

/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good10.bminor.s: Assembler messages:
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good10.bminor.s:14: Error: bad register name `%%rdi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good10.bminor.s:102: Error: bad register name `%%rdi'

return code: 1


===[good11.bminor Input]===
main: function integer () = {
	x: integer = 20;
	y: integer = x;
	{
		x: integer = 10;
		y = y + x;
	}

	{
		{
			y = y + x;
			x: integer = 2;
			y = y + x;
		}
		y = y + x;
		x: integer = 3;
		y = y + x;
	}
	return y + x;
}

===[good11.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good11.bminor"
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $40, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# DECL
# code for value of decl x
# EXPR
	movq $20, %rbx
# code for decl x
	movq %rbx, -8(%rbp)
# STMT
# DECL
# code for value of decl y
# EXPR
# code for decl y
	movq %rbx, -16(%rbp)
# STMT
# STMT
# DECL
# code for value of decl x
# EXPR
	movq $10, %rbx
# code for decl x
	movq %rbx, -24(%rbp)
# STMT
# EXPR
# STMT
# STMT
# STMT
# EXPR
# STMT
# DECL
# code for value of decl x
# EXPR
	movq $2, %rbx
# code for decl x
	movq %rbx, -32(%rbp)
# STMT
# EXPR
# STMT
# EXPR
# STMT
# DECL
# code for value of decl x
# EXPR
	movq $3, %rbx
# code for decl x
	movq %rbx, -40(%rbp)
# STMT
# EXPR
# STMT
# return stmt
# EXPR
# code of add
# EXPR
# EXPR
	addq %rbx, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

============= Your Output ===========


===[good11.bminor Output]===


return code: 6


===[good12.bminor Input]===
main: function integer () = {
	return 4 + 9 / (-2 - (-5)) + (((2 + 1) * 4) - 1) % 3 * 7 - 8;
}

===[good12.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good12.bminor"
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# return stmt
# EXPR
# code of sub
# EXPR
# code of add
# EXPR
# code of add
# EXPR
	movq $4, %rbx
# EXPR
# code of div
# EXPR
	movq $9, %r10
# EXPR
# code of sub
# EXPR
	movq $-2, %r11
# EXPR
	movq $-5, %r12
	subq %r11, %r12
	movq %r10, %rax
	xor %rdx, %rdx
	idivq %r12
	movq %rax, %r12
	addq %rbx, %r12
# EXPR
# code of mult
# EXPR
# code of mod
# EXPR
# code of sub
# EXPR
# code of mult
# EXPR
# code of add
# EXPR
	movq $2, %rbx
# EXPR
	movq $1, %r10
	addq %rbx, %r10
# EXPR
	movq $4, %rbx
	movq %rbx, %rax
	imulq %r10
	movq %rax, %rbx
# EXPR
	movq $1, %r10
	subq %rbx, %r10
# EXPR
	movq $3, %rbx
	movq %r10, %rax
	idivq %rbx
	movq %rax, %rbx
# EXPR
	movq $7, %r10
	movq %r10, %rax
	imulq %rbx
	movq %rax, %r10
	addq %r12, %r10
# EXPR
	movq $8, %rbx
	subq %r10, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

============= Your Output ===========


===[good12.bminor Output]===


return code: 208


===[good13.bminor Input]===
foo_epilogue: function integer () = {
	return 2;
}

foo: function integer ();

main: function integer () = {
	return foo() * 11;
}

main_epilogue: function integer () = {
	return foo_epilogue() + 3;
}

foo: function integer () = {
	return main_epilogue() - 1;
}

===Compiler returned nonzero return code===
parse error: syntax error
Parse failed.


===[good13.bminor Assembly Output]===
.data

.text
.global foo_epilogue
foo_epilogue:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body
movq $2, %rbx
movq %rbx, %rax
jmp .foo_epilogue_epilogue


.foo_epilogue_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global foo
foo:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body


.foo_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global main
main:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body
movq $11, %rbx

# Function call 
pushq %r10
pushq %r11
call foo
popq %r11
popq %r10

movq %rax, %r10
movq %r10, %rax
imulq %rbx
movq %rax, %r10
movq %r10, %rax
jmp .main_epilogue


.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global main_epilogue
main_epilogue:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body
movq $3, %rbx

# Function call 
pushq %r10
pushq %r11
call foo_epilogue
popq %r11
popq %r10

movq %rax, %r10
addq %rbx, %r10
movq %r10, %rax
jmp .main_epilogue_epilogue


.main_epilogue_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global foo
foo:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body
movq $1, %rbx

# Function call 
pushq %r10
pushq %r11
call main_epilogue
popq %r11
popq %r10

movq %rax, %r10
subq %rbx, %r10
movq %r10, %rax
jmp .foo_epilogue


.foo_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

TEST NOT PASSED - COMPILE ERROR

===[good13.bminor Output]===

/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good13.bminor.s: Assembler messages:
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good13.bminor.s:140: Error: symbol `foo' is already defined
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good13.bminor.s:169: Error: symbol `.foo_epilogue' is already defined

return code: 1


===[good15.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=179

strdup: function string (s: string);

main: function integer () = {
	a: string = "sssss";
	b: string = strdup(a);
	if (a==b) return 22; else return 11;
}

===Compiler returned nonzero return code===
strdup:function string ( s: string );
main:function integer () = {
	a:string = "sssss";
	b:string = strdup[(null)(a)];
	if (a == b) {
		return 22;
	}
	else {
		return 11;
	}
}
strdup resolves to global strdup
resolve error: (null) is not defined
a resolves to local 1
a resolves to local 1
b resolves to local 2


===[good15.bminor Assembly Output]===

TEST NOT PASSED - COMPILE ERROR

===[good15.bminor Output]===

/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o: In function `_start':
(.text+0x24): undefined reference to `main'
collect2: error: ld returned 1 exit status

return code: 1


===[good16.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=176

main: function integer() = {
	print "Testing printing literals", '\n', 123, "abc", true, false, 5;
	return 0;
}


===[good16.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good16.bminor"
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# printing exprs
	pushq %r10
	pushq %r11
# EXPR
.data
.L0:
	.string "Testing printing literals"
.text
	leaq .L0, %rbx
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
	movq $110, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
	movq $123, %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
.data
.L1:
	.string "abc"
.text
	leaq .L1, %rbx
	movq %rbx, %rdi
	call print_string
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
	movq $0, %rbx
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
	movq $1, %rbx
	movq %rbx, %rdi
	call print_boolean
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
	movq $5, %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
# STMT
# return stmt
# EXPR
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

============= Your Output ===========

Testing printing literalsn123abcfalsetrue5
===[good16.bminor Output]===
Testing printing literalsn123abcfalsetrue5

return code: 0


===[good17.bminor Input]===
a1: integer;
a2: integer = 111;
a3: boolean = false;

A: function integer() = {
	if (a3) return a1 * a2;
	a2: integer = 3;
	if (!!!a3) return a1 + a2;
	return 0;
}

main: function integer() = { return A(); }

===Compiler returned nonzero return code===
parse error: syntax error
Parse failed.


===[good17.bminor Assembly Output]===

TEST NOT PASSED - COMPILE ERROR

===[good17.bminor Output]===

/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o: In function `_start':
(.text+0x24): undefined reference to `main'
collect2: error: ld returned 1 exit status

return code: 1


===[good18.bminor Input]===
b1: integer = 3;
b2: integer = 6;
b3: integer = 9;

B: function integer(b3: integer, b4: integer) = {
	print b1 * b2 + b3 % b4;
	print '\n';
	b3 = 37;
	return b3;
}

main: function integer () = {
	print B(5, 3);
	return b3;
}

===Compiler returned nonzero return code===


===[good18.bminor Assembly Output]===
.data
b1:
	.quad 3
.data
b2:
	.quad 6
.data
b3:
	.quad 9
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global B
B:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %%rdi
	PUSHQ %%rsi
	SUBQ $16, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ b1, %rbx
	MOVQ b2, %r10
	MOVQ %rbx, %rax
	IMUL %r10
	MOVQ %rax, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ -16(%rbp), %r11
	MOVQ %r10, %rax
	CQO
	IDIVQ %r11
	MOVQ %rdx, %r12
	ADDQ %rbx, %r12
	MOVQ %r12, %rdi
	CALL print_integer
	MOVQ $92, %rbx
	MOVQ %rbx, %rdi
	CALL print_character
	MOVQ $37, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rax
	JMP .B_epilogue
.B_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
	MOVQ $5, %rbx
MOVQ %rbx, %%rdi
	MOVQ $3, %rbx
MOVQ %rbx, %%rsi
CALL B
	POPQ %r11
	POPQ %r10
MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	CALL print_integer
	MOVQ b3, %rbx
	MOVQ %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	MOVQ $0, %rax
	RET

TEST NOT PASSED - COMPILE ERROR

===[good18.bminor Output]===

/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good18.bminor.s: Assembler messages:
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good18.bminor.s:20: Error: bad register name `%%rdi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good18.bminor.s:21: Error: bad register name `%%rsi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good18.bminor.s:78: Error: bad register name `%%rdi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good18.bminor.s:80: Error: bad register name `%%rsi'

return code: 1


===[good19.bminor Input]===
c1: integer = -1;
c3: integer = 100;

d1: integer = 1;
d2: integer = 2;

C: function integer(c1: integer, c2: integer) = {
	c3: integer = 11;
	c4: integer = 12;
	c5: integer = 13;
	return c1 + c2 + c3 + c4;
}

D: function integer(d1: integer, d2: integer) = {
	d3: integer = -3;
	d4: integer = 4;
	d5: integer = 5;
	return d1 + d2 + d3 - d4;
}

main: function integer() = {
	f: integer = D(6, 7);
	return C(1, 2);
}

===Compiler returned nonzero return code===


===[good19.bminor Assembly Output]===
.data
c1:	.quad 0
c3:	.quad 100
d1:	.quad 1
d2:	.quad 2

.text
.global C
C:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
pushq %rsi
subq $24, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body
movq $11, %rbx
movq %rbx, -24(%rbp)
movq $12, %rbx
movq %rbx, -32(%rbp)
movq $13, %rbx
movq %rbx, -40(%rbp)

# Name
movq -32(%rbp), %rbx

# Name
movq -24(%rbp), %r10

# Name
movq -16(%rbp), %r11

# Name
movq -8(%rbp), %r12
addq %r11, %r12
addq %r10, %r12
addq %rbx, %r12
movq %r12, %rax
jmp .C_epilogue


.C_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global D
D:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
pushq %rsi
subq $24, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body
movq $3, %rbx
notq %rbx
addq $1, %rbx
movq %rbx, -24(%rbp)
movq $4, %rbx
movq %rbx, -32(%rbp)
movq $5, %rbx
movq %rbx, -40(%rbp)

# Name
movq -32(%rbp), %rbx

# Name
movq -24(%rbp), %r10

# Name
movq -16(%rbp), %r11

# Name
movq -8(%rbp), %r12
addq %r11, %r12
addq %r10, %r12
subq %rbx, %r12
movq %r12, %rax
jmp .D_epilogue


.D_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global main
main:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
subq $8, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body

# Function call 
movq $6, %rbx
movq $7, %r10
movq %rbx, %rdi
movq %r10, %rsi
pushq %r10
pushq %r11
call D
popq %r11
popq %r10

movq %rax, %rbx
movq %rbx, -8(%rbp)

# Function call 
movq $1, %rbx
movq $2, %r10
movq %rbx, %rdi
movq %r10, %rsi
pushq %r10
pushq %r11
call C
popq %r11
popq %r10

movq %rax, %rbx
movq %rbx, %rax
jmp .main_epilogue


.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

============= Your Output ===========


===[good19.bminor Output]===


return code: 26


===[good20.bminor Input]===
D: function integer() = {
	d1: integer = 5;
	d2: integer = d1 + 1; //6
	{
		d3: integer = 9;
		d2: integer = d3 + d1 - 3; //11
		d4: integer = -1;
		d2 = d2 + d3; //20
		print d2 - d4, "\n";
	}
	d4: integer = 16;
	print d2 - d4, '\n';
	{
		d4: integer = -2;
		d3: integer = 1000;
		print d3 + 10;
		print "\n";
		print d4;
		print '\n';
	}
	print d4;
	return 3;
}

main: function integer () = {
	return D();
}

===Compiler returned nonzero return code===
parse error: syntax error
Parse failed.


===[good20.bminor Assembly Output]===
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global D
D:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $64, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $5, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ $1, %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -16(%rbp)
	MOVQ $9, %rbx
	MOVQ %rbx, -24(%rbp)
	MOVQ -24(%rbp), %rbx
	MOVQ -8(%rbp), %r10
	ADDQ %rbx, %r10
	MOVQ $3, %rbx
	SUBQ %rbx, %r10
	MOVQ %r10, -32(%rbp)
	MOVQ $1, %rbx
	NEGQ %rbx
	MOVQ %rbx, -40(%rbp)
	MOVQ -32(%rbp), %rbx
	MOVQ -24(%rbp), %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -32(%rbp)
	MOVQ -32(%rbp), %rbx
	MOVQ -40(%rbp), %r10
	SUBQ %r10, %rbx
	MOVQ %rbx, %rdi
	CALL print_integer
.data
.L0:
	.string "\n"
.text
MOVQ $.L0, %rbx
	MOVQ %rbx, %rdi
	CALL print_string
	MOVQ $16, %rbx
	MOVQ %rbx, -48(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -48(%rbp), %r10
	SUBQ %r10, %rbx
	MOVQ %rbx, %rdi
	CALL print_integer
	MOVQ $92, %rbx
	MOVQ %rbx, %rdi
	CALL print_character
	MOVQ $2, %rbx
	NEGQ %rbx
	MOVQ %rbx, -56(%rbp)
	MOVQ $1000, %rbx
	MOVQ %rbx, -64(%rbp)
	MOVQ -64(%rbp), %rbx
	MOVQ $10, %r10
	ADDQ %rbx, %r10
	MOVQ %r10, %rdi
	CALL print_integer
.data
.L1:
	.string "\n"
.text
MOVQ $.L1, %rbx
	MOVQ %rbx, %rdi
	CALL print_string
	MOVQ -56(%rbp), %rbx
	MOVQ %rbx, %rdi
	CALL print_integer
	MOVQ $92, %rbx
	MOVQ %rbx, %rdi
	CALL print_character
	MOVQ -48(%rbp), %rbx
	MOVQ %rbx, %rdi
	CALL print_integer
	MOVQ $3, %rbx
	MOVQ %rbx, %rax
	JMP .D_epilogue
.D_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
CALL D
	POPQ %r11
	POPQ %r10
MOVQ %rax, %rbx
	MOVQ %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	MOVQ $0, %rax
	RET

============= Your Output ===========

21
-10\1010
-2\16
===[good20.bminor Output]===
21
-10\1010
-2\16

return code: 0


===[good3.bminor Input]===
T: array [8] integer = {2, 1, 1, 2, 1, 2, 0, 3};

main:function integer ()=
{
	i: integer = 0;
        for (;;) {
		if (T[i] == 0) return T[5] + 10;
		else if (T[i] == 1) i++;
		else if (T[i] == 2) T[i++]--;
		else return 1;
	}

	return 0;
}

===[good3.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good3.bminor"
# DECL
.data
.global T
T:
.quad 2
.quad 1
.quad 1
.quad 2
.quad 1
.quad 2
.quad 0
.quad 3
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# DECL
# code for value of decl i
# EXPR
	movq $0, %rbx
# code for decl i
	movq %rbx, -8(%rbp)
# STMT
# start of for loop
# init expr
.L0:
# condition expr
# loop body
# STMT
# STMT
# start of if stmt
# condition expr
# EXPR
# code of cmp 
# EXPR
# EXPR
	movq $0, %rbx
# CMP
	cmpq %rbx, %rbx
	je .L4
# if false
.L5:
	movq $0, %rbx
	jmp .L6
# if true
.L4:
	movq $1, %rbx
	jmp .L6
# continue
.L6:
	cmpq $0, %rbx
	je .L2
# if body
# STMT
# return stmt
# EXPR
# code of add
# EXPR
# EXPR
	movq $10, %rbx
	addq %rbx, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
	jmp .L3
# false label
.L2:
# else body
# STMT
# start of if stmt
# condition expr
# EXPR
# code of cmp 
# EXPR
# EXPR
	movq $1, %rbx
# CMP
	cmpq %rbx, %rbx
	je .L9
# if false
.L10:
	movq $0, %rbx
	jmp .L11
# if true
.L9:
	movq $1, %rbx
	jmp .L11
# continue
.L11:
	cmpq $0, %rbx
	je .L7
# if body
# STMT
# EXPR
# code of ++
# EXPR
	movq %rbx, %rbx
	incq %rbx
	movq %rbx, -8(%rbp)
	jmp .L8
# false label
.L7:
# else body
# STMT
# start of if stmt
# condition expr
# EXPR
# code of cmp 
# EXPR
# EXPR
	movq $2, %rbx
# CMP
	cmpq %rbx, %rbx
	je .L14
# if false
.L15:
	movq $0, %rbx
	jmp .L16
# if true
.L14:
	movq $1, %rbx
	jmp .L16
# continue
.L16:
	cmpq $0, %rbx
	je .L12
# if body
# STMT
# EXPR
# code of --
# EXPR
	movq %rbx, %rbx
	decq %rbx
	movq %rbx, T
	jmp .L13
# false label
.L12:
# else body
# STMT
# return stmt
# EXPR
	movq $1, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
.L13:
# end of if stmt
.L8:
# end of if stmt
.L3:
# end of if stmt
# next expr
	jmp .L0
.L1:
# end of for loop
# STMT
# return stmt
# EXPR
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

============= Your Output ===========


===[good3.bminor Output]===


return code: 20


===[good2.bminor Input]===


X: array [4] integer = {11, 30, 22, 0};

main: function integer () = {
	i: integer;
	for (i = 0; X[i] != 0; i++)
		print X[i], ' ', X[i] % 3, '\n';

	return 0;
}

===[good2.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good2.bminor"
# DECL
.data
.global X
X:
.quad 11
.quad 30
.quad 22
.quad 0
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $8, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# DECL
# STMT
# start of for loop
# init expr
# EXPR
.L0:
# condition expr
# EXPR
# code of cmp 
# EXPR
# EXPR
	movq $0, %rbx
# CMP
	cmpq %rbx, %rbx
	jne .L2
# if false
.L3:
	movq $0, %rbx
	jmp .L4
# if true
.L2:
	movq $1, %rbx
	jmp .L4
# continue
.L4:
	cmpq $0, %rbx
	je .L1
# loop body
# STMT
# printing exprs
	pushq %r10
	pushq %r11
# EXPR
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
	movq $32, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
# code of mod
# EXPR
# EXPR
	movq $3, %rbx
	movq %rbx, %rax
	idivq %rbx
	movq %rax, %rbx
	movq %rbx, %rdi
	call print_integer
	popq %r11
	popq %r10
	pushq %r10
	pushq %r11
# EXPR
	movq $110, %rbx
	movq %rbx, %rdi
	call print_character
	popq %r11
	popq %r10
# next expr
# EXPR
# code of ++
# EXPR
	movq %rbx, %rbx
	incq %rbx
	movq %rbx, -8(%rbp)
	jmp .L0
.L1:
# end of for loop
# STMT
# return stmt
# EXPR
	movq $0, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

============= Your Output ===========


===[good2.bminor Output]===


return code: 0


===[good5.bminor Input]===
A: function boolean(x: integer, y: integer);
B: function integer(x: char);
C: function char(a: string);

main: function integer() = {
	if (A(B('d') - 1, 10)) {
		x: integer = 3;
		return 2 * B('!') + x;
	}
	return B(C("hello")) % 3;
}

A: function boolean(x: integer, y: integer) = {
	return x == y;
}

B: function integer(c: char) = {
	if (c == '!')
		return 10;
	else {return 11;}
}

C: function char(a: string) = {
	return '!';
}

===Compiler returned nonzero return code===


===[good5.bminor Assembly Output]===
.data
.L0: .string "hello"

.text
.global A
A:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
pushq %rsi
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body


.A_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global B
B:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body


.B_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global C
C:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body


.C_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global main
main:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
subq $8, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body

# Function call 
movq $1, %rbx

# Function call 
movq $100, %r10
movq %r10, %rdi
pushq %r10
pushq %r11
call B
popq %r11
popq %r10

movq %rax, %r10
subq %rbx, %r10
movq $10, %rbx
movq %r10, %rdi
movq %rbx, %rsi
pushq %r10
pushq %r11
call A
popq %r11
popq %r10

movq %rax, %rbx
cmp $0, %rbx
je .L1
movq $3, %r10
movq %r10, -8(%rbp)

# Name
movq -8(%rbp), %r10

# Function call 
movq $33, %r11
movq %r11, %rdi
pushq %r10
pushq %r11
call B
popq %r11
popq %r10

movq %rax, %r11
movq $2, %r12
movq %r12, %rax
imulq %r11
movq %rax, %r12
addq %r10, %r12
movq %r12, %rax
jmp .main_epilogue
jmp .L2
.L1:
.L2:

# Function call 

# Function call 
movq $.L0, %rbx
movq %rbx, %rdi
pushq %r10
pushq %r11
call C
popq %r11
popq %r10

movq %rax, %rbx
movq %rbx, %rdi
pushq %r10
pushq %r11
call B
popq %r11
popq %r10

movq %rax, %rbx
movq $3, %r10
movq %rbx, %rax
cqo
idivq %r10
movq %rdx, %rbx
movq %rbx, %rax
jmp .main_epilogue


.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global A
A:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
pushq %rsi
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body

# Name
movq -16(%rbp), %rbx

# Name
movq -8(%rbp), %r10
cmp %rbx, %r10
je .L3
movq $0, %r10
jmp .L4
.L3:
movq $1, %r10
.L4:
movq %r10, %rax
jmp .A_epilogue


.A_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global B
B:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body
movq $33, %rbx

# Name
movq -8(%rbp), %r10
cmp %rbx, %r10
je .L5
movq $0, %r10
jmp .L6
.L5:
movq $1, %r10
.L6:
cmp $0, %r10
je .L7
movq $10, %rbx
movq %rbx, %rax
jmp .B_epilogue
jmp .L8
.L7:
movq $11, %rbx
movq %rbx, %rax
jmp .B_epilogue
.L8:


.B_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global C
C:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body
movq $33, %rbx
movq %rbx, %rax
jmp .C_epilogue


.C_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

TEST NOT PASSED - COMPILE ERROR

===[good5.bminor Output]===

/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good5.bminor.s: Assembler messages:
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good5.bminor.s:195: Error: symbol `A' is already defined
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good5.bminor.s:228: Error: symbol `.A_epilogue' is already defined
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good5.bminor.s:238: Error: symbol `B' is already defined
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good5.bminor.s:277: Error: symbol `.B_epilogue' is already defined
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good5.bminor.s:287: Error: symbol `C' is already defined
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good5.bminor.s:307: Error: symbol `.C_epilogue' is already defined

return code: 1


===[good6.bminor Input]===
f: function boolean(b: boolean) = {
	return !b;
}

x: integer = -4;

main:function integer ()=
{
	y: integer = 10;
	if (f(f(f(f(f(x <= y)))))) return 1;
	else if (x < y - x*y) {
		return 4;
	} else return 2;
}

===Compiler returned nonzero return code===


===[good6.bminor Assembly Output]===
.data
x:	.quad 0

.text
.global f
f:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
pushq %rdi
subq $0, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body

# Name
movq -8(%rbp), %rbx
cmp $0, %rbx
je .L0
movq $0, %rbx
jmp .L1
.L0:
movq $1, %rbx
.L1:
movq %rbx, %rax
jmp .f_epilogue


.f_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret
.global main
main:
pushq %rbp
movq %rsp, %rbp

# Save arguments and allocate local variables
subq $8, %rsp

pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15

# Function body
movq $10, %rbx
movq %rbx, -8(%rbp)

# Function call 

# Function call 

# Function call 

# Function call 

# Function call 

# Name
movq -8(%rbp), %rbx

# Name
movq x, %r10
cmp %rbx, %r10
jle .L2
movq $0, %r10
jmp .L3
.L2:
movq $1, %r10
.L3:
movq %r10, %rdi
pushq %r10
pushq %r11
call f
popq %r11
popq %r10

movq %rax, %rbx
movq %rbx, %rdi
pushq %r10
pushq %r11
call f
popq %r11
popq %r10

movq %rax, %rbx
movq %rbx, %rdi
pushq %r10
pushq %r11
call f
popq %r11
popq %r10

movq %rax, %rbx
movq %rbx, %rdi
pushq %r10
pushq %r11
call f
popq %r11
popq %r10

movq %rax, %rbx
movq %rbx, %rdi
pushq %r10
pushq %r11
call f
popq %r11
popq %r10

movq %rax, %rbx
cmp $0, %rbx
je .L4
movq $1, %r10
movq %r10, %rax
jmp .main_epilogue
jmp .L5
.L4:

# Name
movq -8(%rbp), %r10

# Name
movq x, %r11
movq %r11, %rax
imulq %r10
movq %rax, %r11

# Name
movq -8(%rbp), %r10
subq %r11, %r10

# Name
movq x, %r11
cmp %r10, %r11
jl .L6
movq $0, %r11
jmp .L7
.L6:
movq $1, %r11
.L7:
cmp $0, %r11
je .L8
movq $4, %r10
movq %r10, %rax
jmp .main_epilogue
jmp .L9
.L8:
movq $2, %r10
movq %r10, %rax
jmp .main_epilogue
.L9:
.L5:


.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

============= Your Output ===========


===[good6.bminor Output]===


return code: 4


===[good7.bminor Input]===
f: function void (i: integer) = {
	N: integer;
	for (N = 0; i > 0; i--) {
		print N;
		N = N + 1;
	}
}

main:function integer () = {
	N: integer = 6;
	for (;;N--) {
		f(N);
		print '\n';
		if (N == 0) return 0;
	}

	return 1;
}

===Compiler returned nonzero return code===


===[good7.bminor Assembly Output]===
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global f
f:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %%rdi
	SUBQ $16, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $0, %rbx
	MOVQ %rbx, -8(%rbp)
.L0:
	MOVQ -8(%rbp), %rbx
	MOVQ $0, %r10
	CMPQ %r10, %rbx
	JG .L2
	MOVQ $0, %rbx
	JMP .L3
.L2:
	MOVQ $1, %rbx
.L3:
	CMP $0, %rbx
	JE .L1
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	CALL print_integer
	MOVQ -8(%rbp), %rbx
	MOVQ $1, %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	SUBQ $1, %rbx
	MOVQ %rbx, -8(%rbp)
	JMP .L0
.L1:
.f_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $16, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $6, %rbx
	MOVQ %rbx, -8(%rbp)
.L4:
	PUSHQ %r10
	PUSHQ %r11
	MOVQ -8(%rbp), %rbx
MOVQ %rbx, %%rdi
CALL f
	POPQ %r11
	POPQ %r10
MOVQ %rax, %rbx
	MOVQ $92, %rbx
	MOVQ %rbx, %rdi
	CALL print_character
	MOVQ -8(%rbp), %rbx
	MOVQ $0, %r10
	CMPQ %r10, %rbx
	JE .L8
	MOVQ $0, %rbx
	JMP .L9
.L8:
	MOVQ $1, %rbx
.L9:
CMP $0, %rbx
JE .L6
	MOVQ $0, %rbx
	MOVQ %rbx, %rax
	JMP .main_epilogue
JMP .L7
.L6:
.L7:
	MOVQ -8(%rbp), %rbx
	SUBQ $1, %rbx
	MOVQ %rbx, -8(%rbp)
	JMP .L4
.L5:
	MOVQ $1, %rbx
	MOVQ %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	MOVQ $0, %rax
	RET

TEST NOT PASSED - COMPILE ERROR

===[good7.bminor Output]===

/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good7.bminor.s: Assembler messages:
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good7.bminor.s:11: Error: bad register name `%%rdi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good7.bminor.s:75: Error: bad register name `%%rdi'

return code: 1


===[good8.bminor Input]===
abs: function integer(n: integer);

digits: array [6] integer = {
	14,
	8,
	6168,
	42,
	0,
	74546
};

main:function integer () = {
	digits[4] = -468;
	i: integer = 0;
	for (; abs(digits[i]) == digits[i];) {
		print digits[i];
		i = i + 1;
		print ' ';
	}
	print '\n';

	return 0;
}

===Compiler returned nonzero return code===
abs:function integer ( n: integer );
digits:array[6] integer = {14, 8, 6168, 42, 0, 74546};
main:function integer () = {
}
digits resolves to global digits
abs resolves to global abs
resolve error: (null) is not defined
digits resolves to global digits
i resolves to local 1
digits resolves to global digits
i resolves to local 1
digits resolves to global digits
i resolves to local 1
i resolves to local 1
i resolves to local 1


===[good8.bminor Assembly Output]===

TEST NOT PASSED - COMPILE ERROR

===[good8.bminor Output]===

/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o: In function `_start':
(.text+0x24): undefined reference to `main'
collect2: error: ld returned 1 exit status

return code: 1


===[good9.bminor Input]===
a: array[4] integer;
main: function integer() = {
	a[2] = 60;
	return a[2] + a[2] / 20 * 3 - a[1];
}

===[good9.bminor Assembly Output]===
.file "/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good9.bminor"
# DECL
.data
.global a
a:
.quad 0
.quad 0
.quad 0
.quad 0
# DECL
.text
.global main
main:
# start of function prologue
	pushq %rbp
	movq %rsp, %rbp

	subq $0, %rsp
	pushq %rbx
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
# end of functiop prologue
# STMT
# STMT
# EXPR
# STMT
# return stmt
# EXPR
# code of sub
# EXPR
# code of add
# EXPR
# EXPR
# code of mult
# EXPR
# code of div
# EXPR
# EXPR
	movq $20, %rbx
	movq %rbx, %rax
	xor %rdx, %rdx
	idivq %rbx
	movq %rax, %rbx
# EXPR
	movq $3, %rbx
	movq %rbx, %rax
	imulq %rbx
	movq %rax, %rbx
	addq %rbx, %rbx
# EXPR
	subq %rbx, %rbx
	movq %rbx, %rax
	jmp .main_epilogue
# start of function epilogue
.main_epilogue:
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	movq %rbp, %rsp
	popq %rbp
	ret
# end of function epilogue

============= Your Output ===========


===[good9.bminor Output]===


return code: 0


===[good14.bminor Input]===
/*
Return pointer to (constant) global
string which is valid to display.
*/

s: string = "ok\n";

f: function string() = {
	t: string = s;
	return t;
}

main: function integer () = {
	print f();
	return 0;
}

===Compiler returned nonzero return code===
parse error: syntax error
Parse failed.


===[good14.bminor Assembly Output]===
.data
s:
	.string "ok\n"
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global f
f:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $16, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	LEAQ s, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rax
	JMP .f_epilogue
.f_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
CALL f
	POPQ %r11
	POPQ %r10
MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	CALL print_string
	MOVQ $0, %rbx
	MOVQ %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	MOVQ $0, %rax
	RET

============= Your Output ===========

ok

===[good14.bminor Output]===
ok


return code: 0


===[good4.bminor Input]===
collatz: function integer(n: integer, acc: integer) = {
	print n, " ", acc, "\n";
	if (n == 1) return acc;

	if (n % 2 == 0) return collatz(n/2, acc + 1);
	else return collatz(3*n + 1, acc + 1);
}

main:function integer ()=
{
	return collatz(27, 0);
}

===Compiler returned nonzero return code===
collatz:function integer ( n: integer, acc: integer ) = {
	print n, " ", acc, "\n";
	if (n == 1) {
		return acc;
	}
	if (n % 2 == 0) {
		return collatz[(null)(n / 2, acc + 1)];
	}
	else {
		return collatz[(null)(3 * n + 1, acc + 1)];
	}
}
main:function integer () = {
	return collatz[(null)(27, 0)];
}
n resolves to param 1
acc resolves to param 2
n resolves to param 1
acc resolves to param 2
n resolves to param 1
collatz resolves to global collatz
resolve error: (null) is not defined
n resolves to param 1
acc resolves to param 2
collatz resolves to global collatz
resolve error: (null) is not defined
n resolves to param 1
acc resolves to param 2


===[good4.bminor Assembly Output]===
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global collatz
collatz:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %%rdi
	PUSHQ %%rsi
	SUBQ $16, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	CALL print_integer
.data
.L0:
	.string " "
.text
MOVQ $.L0, %rbx
	MOVQ %rbx, %rdi
	CALL print_string
	MOVQ -16(%rbp), %rbx
	MOVQ %rbx, %rdi
	CALL print_integer
.data
.L1:
	.string "\n"
.text
MOVQ $.L1, %rbx
	MOVQ %rbx, %rdi
	CALL print_string
	MOVQ -8(%rbp), %rbx
	MOVQ $1, %r10
	CMPQ %r10, %rbx
	JE .L4
	MOVQ $0, %rbx
	JMP .L5
.L4:
	MOVQ $1, %rbx
.L5:
CMP $0, %rbx
JE .L2
	MOVQ -16(%rbp), %rbx
	MOVQ %rbx, %rax
	JMP .collatz_epilogue
JMP .L3
.L2:
.L3:
	MOVQ -8(%rbp), %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rax
	CQO
	IDIVQ %r10
	MOVQ %rdx, %r11
	MOVQ $0, %rbx
	CMPQ %rbx, %r11
	JE .L8
	MOVQ $0, %r11
	JMP .L9
.L8:
	MOVQ $1, %r11
.L9:
CMP $0, %r11
JE .L6
	PUSHQ %r10
	PUSHQ %r11
	MOVQ -8(%rbp), %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rax
	CQO
	IDIVQ %r10
	MOVQ %rax, %r11
MOVQ %rbx, %%rdi
	MOVQ -16(%rbp), %rbx
	MOVQ $1, %r10
	ADDQ %rbx, %r10
MOVQ %rbx, %%rsi
CALL collatz
	POPQ %r11
	POPQ %r10
MOVQ %rax, %rbx
	MOVQ %rbx, %rax
	JMP .collatz_epilogue
JMP .L7
.L6:
	PUSHQ %r10
	PUSHQ %r11
	MOVQ $3, %rbx
	MOVQ -8(%rbp), %r12
	MOVQ %rbx, %rax
	IMUL %r12
	MOVQ %rax, %rbx
	MOVQ $1, %r12
	ADDQ %rbx, %r12
MOVQ %rbx, %%rdi
	MOVQ -16(%rbp), %rbx
	MOVQ $1, %r13
	ADDQ %rbx, %r13
MOVQ %rbx, %%rsi
CALL collatz
	POPQ %r11
	POPQ %r10
MOVQ %rax, %rbx
	MOVQ %rbx, %rax
	JMP .collatz_epilogue
.L7:
.collatz_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.extern print_integer
.extern print_string
.extern print_character
.extern print_boolean
.extern integer_power
.global main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
	MOVQ $27, %rbx
MOVQ %rbx, %%rdi
	MOVQ $0, %rbx
MOVQ %rbx, %%rsi
CALL collatz
	POPQ %r11
	POPQ %r10
MOVQ %rax, %rbx
	MOVQ %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %rbx
	POPQ %r12
	POPQ %r13
	POPQ %r14
	POPQ %r15
	MOVQ %rbp, %rsp
	POPQ %rbp
	MOVQ $0, %rax
	RET

TEST NOT PASSED - COMPILE ERROR

===[good4.bminor Output]===

/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good4.bminor.s: Assembler messages:
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good4.bminor.s:11: Error: bad register name `%%rdi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good4.bminor.s:12: Error: bad register name `%%rsi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good4.bminor.s:80: Error: bad register name `%%rdi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good4.bminor.s:84: Error: bad register name `%%rsi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good4.bminor.s:102: Error: bad register name `%%rdi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good4.bminor.s:106: Error: bad register name `%%rsi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good4.bminor.s:142: Error: bad register name `%%rdi'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good4.bminor.s:144: Error: bad register name `%%rsi'

return code: 1


===== SUMMARIZED CODEGEN RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 20,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 10,
      "incorrect": 10
    }
  }
}

Codegen Project
--------------------

General Structure (25/25 points)
----------------------------------------------
General structure looks good

Codegen - Functionality (15/15 points)
----------------------------------------------

Generated code:
	- Generated assembly compiles and runs on student machines without added effort (+5)
	- Runs with expected output, exit code, etc (+5)
	- Function calls and stack management working properly (+5)
	

Codegen - Assembly Structure (10/10 points)
----------------------------------------------

Generated code:
	- A file containing at least mostly complete assembly was generated (+5)
	- Loops and conditionals are implemented with jumps and labels (+5)

Student Tests (20/20 points)
------------------------------------------
Test cases look well done!

Hidden Tests (10/20 points)
------------------------------------------
Looks like you had compile errors and some of the different hidden test cases

Coding Style (10/10 points)
------------------------------------------
Nice coding style


