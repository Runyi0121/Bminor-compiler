/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_EOF
%token TOKEN_CCOMMENT
%token TOKEN_CPLUSCOMMENT
%token TOKEN_ARRAY
%token TOKEN_AUTO
%token TOKEN_BOOLEAN
%token TOKEN_CHAR
%token TOKEN_ELSE
%token TOKEN_FALSE
%token TOKEN_FLOAT
%token TOKEN_FOR
%token TOKEN_FUNCTION
%token TOKEN_IF
%token TOKEN_INTEGER
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_STRING
%token TOKEN_TRUE
%token TOKEN_VOID
%token TOKEN_WHILE
%token TOKEN_SPECIALCHAR
%token TOKEN_ADD
%token TOKEN_SUBTRACT
%token TOKEN_INCREMENT
%token TOKEN_DECREMENT
%token TOKEN_FRONTPARENTHESE
%token TOKEN_BACKPARENTHESE
%token TOKEN_FRONTSQUAREBRACKET
%token TOKEN_BACKSQUAREBRACKET
%token TOKEN_FRONTCURLYBRACKET
%token TOKEN_BACKCURLYBRACKET
%token TOKEN_NEGATIVE
%token TOKEN_LOGICALNOT
%token TOKEN_EXPONENTIAL
%token TOKEN_MULTIPLY
%token TOKEN_DIVIDE
%token TOKEN_REMAIN
%token TOKEN_LESSTHAN
%token TOKEN_LESSEQUAL
%token TOKEN_GREATERTHAN
%token TOKEN_GREATEREQUAL
%token TOKEN_EQUAL
%token TOKEN_NOTEQUAL
%token TOKEN_AND
%token TOKEN_OR
%token TOKEN_ASSIGN
%token TOKEN_COLON
%token TOKEN_SEMICOLON
%token TOKEN_COMMA
%token TOKEN_PERCENT
%token TOKEN_TYPE_CHAR
%token TOKEN_TYPE_INT
%token TOKEN_TYPE_FLOAT
%token TOKEN_TYPE_IDENT
%token TOKEN_TYPE_STRING
%token TOKEN_ERROR

%{

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "../inc/expr.h"

/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are returning a pointer to an expression.
*/

#define YYSTYPE struct expr *

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

%}

%%

/* Here is the grammar: program is the start symbol. */

program : decl_list {return 0;}
	;

decl_list: decl decl_list
	| 
	;

decl: TOKEN_TYPE_IDENT TOKEN_COLON type TOKEN_SEMICOLON
	| TOKEN_TYPE_IDENT TOKEN_COLON type TOKEN_ASSIGN expr_list TOKEN_SEMICOLON
	| TOKEN_TYPE_IDENT TOKEN_COLON type TOKEN_ASSIGN TOKEN_FRONTCURLYBRACKET stmt_array TOKEN_BACKCURLYBRACKET
	;

array_content: expr TOKEN_COMMA array_content 
	| expr
	;

type: TOKEN_INTEGER
	| TOKEN_BOOLEAN
	| TOKEN_ARRAY TOKEN_FRONTSQUAREBRACKET optional_stmt TOKEN_BACKSQUAREBRACKET type
	| TOKEN_CHAR
	| TOKEN_FLOAT
	| TOKEN_STRING
	| TOKEN_VOID
	| TOKEN_AUTO
	| TOKEN_FUNCTION type TOKEN_FRONTPARENTHESE arg_lists TOKEN_BACKPARENTHESE

arg_lists: arg_list
	|
	;

arg_list: arg TOKEN_COMMA arg_list
	| arg
	;

arg: TOKEN_TYPE_IDENT TOKEN_COLON type
	;

stmt_array: stmt_list
	| array_content
	;

stmt_list: stmt_list stmt
	| stmt
	;

stmt: stmt_recursive
	| stmt_closed
	;

stmt_recursive: TOKEN_FOR TOKEN_FRONTPARENTHESE optional_stmt TOKEN_SEMICOLON optional_stmt TOKEN_SEMICOLON optional_stmt TOKEN_BACKPARENTHESE stmt_recursive
	| TOKEN_IF TOKEN_FRONTPARENTHESE expr TOKEN_BACKPARENTHESE stmt_closed TOKEN_ELSE stmt_recursive
	| TOKEN_IF TOKEN_FRONTPARENTHESE expr TOKEN_BACKPARENTHESE stmt
	;

stmt_closed: TOKEN_FOR TOKEN_FRONTPARENTHESE optional_stmt TOKEN_SEMICOLON optional_stmt TOKEN_SEMICOLON optional_stmt TOKEN_BACKPARENTHESE stmt_closed
	| TOKEN_IF TOKEN_FRONTPARENTHESE expr TOKEN_BACKPARENTHESE stmt_closed TOKEN_ELSE stmt_closed 
	| stmt_base
	;


stmt_base: expr TOKEN_SEMICOLON
	| TOKEN_RETURN expr TOKEN_SEMICOLON
	| TOKEN_PRINT expr_list TOKEN_SEMICOLON
	| TOKEN_FRONTCURLYBRACKET stmt_list TOKEN_BACKCURLYBRACKET
	| decl
	;

optional_stmt: expr
	|
	;

expr_list: expr TOKEN_COMMA expr_list 
	| expr
	|
	;

expr: expr TOKEN_ASSIGN expr_or
	| expr_or
	;

expr_or	: expr_or TOKEN_OR expr_and { $$ = expr_create(EXPR_OR,$1,$3);}
	| expr_and { $$ = $1; }
	;

expr_and	: expr_and TOKEN_AND expr_comp
		{ $$ = expr_create(EXPR_AND,$1,$3);}
	| expr_comp
		{ $$ = $1; }
	;

expr_comp :  expr_comp TOKEN_LESSTHAN expr_arith1
		{ $$ = expr_create(EXPR_LT,$1,$3); }
	| expr_comp TOKEN_LESSEQUAL expr_arith1
		{ $$ = expr_create(EXPR_LE,$1,$3); }
	| expr_comp TOKEN_GREATERTHAN expr_arith1
		{ $$ = expr_create(EXPR_GT,$1,$3); }
	| expr_comp TOKEN_GREATEREQUAL expr_arith1
		{ $$ = expr_create(EXPR_GE,$1,$3); }
	| expr_comp TOKEN_EQUAL expr_arith1
		{ $$ = expr_create(EXPR_EQ,$1,$3); }
	| expr_comp TOKEN_NOTEQUAL expr_arith1
		{ $$ = expr_create(EXPR_NE,$1,$3); }
	| expr_arith1
		{ $$ = $1; } 
	;

expr_arith1: expr_arith1 TOKEN_ADD expr_arith2
		{ $$ = expr_create(EXPR_AND,$1,$3); }
	| expr_arith1 TOKEN_SUBTRACT expr_arith2
		{ $$ = expr_create(EXPR_SUB,$1,$3); }
	| expr_arith2
		{$$ = $1; }
	;

expr_arith2: expr_arith2 TOKEN_MULTIPLY expr_expo
		{ $$ = expr_create(EXPR_MUL,$1,$3); }
	| expr_arith2 TOKEN_DIVIDE expr_expo
		{ $$ = expr_create(EXPR_DIV,$1,$3); if ($3 == 0){printf("cannot divide by zero!\n");} }
	| expr_arith2 TOKEN_REMAIN expr_expo
		{ $$ = expr_create(EXPR_REMAIN,$1,$3); }
	| expr_expo
		{ $$ = $1; } 
	;

expr_expo: expr_expo TOKEN_EXPONENTIAL expr_not
		{ $$ = expr_create(EXPR_EXPON,$1,$3); }
	| expr_not
		{ $$ = $1; } 
	;

expr_not: TOKEN_SUBTRACT expr_not
	| TOKEN_LOGICALNOT expr_not
	| expr_crement
	;

expr_crement: expr_crement TOKEN_INCREMENT
	| expr_crement TOKEN_DECREMENT
	| expr_group
		{ $$ = $1; }
	;

expr_group: TOKEN_FRONTPARENTHESE expr TOKEN_BACKPARENTHESE
		{ $$ = $2; }
	| expr_base
		{ $$ = $1; }
	;

expr_base: TOKEN_TYPE_CHAR
	| TOKEN_TYPE_INT
	| TOKEN_TRUE
	| TOKEN_FALSE
	| TOKEN_TYPE_FLOAT
	| TOKEN_TYPE_STRING
	| TOKEN_TYPE_IDENT others
	;

others: TOKEN_FRONTSQUAREBRACKET expr TOKEN_BACKSQUAREBRACKET others
	| TOKEN_FRONTPARENTHESE expr_list TOKEN_BACKPARENTHESE
	| 
	;	

%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
	return 0;
}